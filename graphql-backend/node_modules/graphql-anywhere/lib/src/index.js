"use strict";
var getFromAST_1 = require('./getFromAST');
var directives_1 = require('./directives');
var storeUtils_1 = require('./storeUtils');
var isArray = require('lodash.isarray');
var isNull = require('lodash.isnull');
var isUndefined = require('lodash.isundefined');
var merge = require('lodash.merge');
function graphql(resolver, document, rootValue, contextValue, variableValues, resultMapper) {
    var queryDefinition = getFromAST_1.getQueryDefinition(document);
    var fragments = getFromAST_1.getFragmentDefinitions(document);
    var fragmentMap = getFromAST_1.createFragmentMap(fragments) || {};
    var execContext = {
        fragmentMap: fragmentMap,
        contextValue: contextValue,
        variableValues: variableValues,
        resultMapper: resultMapper,
        resolver: resolver,
    };
    return executeSelectionSet(queryDefinition.selectionSet, rootValue, execContext);
}
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = graphql;
var throwOnMissingField = true;
function executeSelectionSet(selectionSet, rootValue, execContext) {
    var fragmentMap = execContext.fragmentMap, contextValue = execContext.contextValue, variables = execContext.variableValues;
    var result = {};
    var fragmentErrors = {};
    selectionSet.selections.forEach(function (selection) {
        if (!directives_1.shouldInclude(selection, variables)) {
            return;
        }
        if (storeUtils_1.isField(selection)) {
            var fieldResult = executeField(selection, rootValue, execContext);
            var resultFieldKey = storeUtils_1.resultKeyNameFromField(selection);
            if (fieldResult !== undefined) {
                result[resultFieldKey] = fieldResult;
            }
        }
        else if (storeUtils_1.isInlineFragment(selection)) {
            var typename = selection.typeCondition.name.value;
            try {
                var inlineFragmentResult = executeSelectionSet(selection.selectionSet, rootValue, execContext);
                merge(result, inlineFragmentResult);
                if (!fragmentErrors[typename]) {
                    fragmentErrors[typename] = null;
                }
            }
            catch (e) {
                if (e.extraInfo && e.extraInfo.isFieldError) {
                    fragmentErrors[typename] = e;
                }
                else {
                    throw e;
                }
            }
        }
        else {
            var fragment = fragmentMap[selection.name.value];
            if (!fragment) {
                throw new Error("No fragment named " + selection.name.value);
            }
            var typename = fragment.typeCondition.name.value;
            try {
                var namedFragmentResult = executeSelectionSet(fragment.selectionSet, rootValue, execContext);
                merge(result, namedFragmentResult);
                if (!fragmentErrors[typename]) {
                    fragmentErrors[typename] = null;
                }
            }
            catch (e) {
                if (e.extraInfo && e.extraInfo.isFieldError) {
                    fragmentErrors[typename] = e;
                }
                else {
                    throw e;
                }
            }
        }
    });
    if (throwOnMissingField) {
        handleFragmentErrors(fragmentErrors);
    }
    if (execContext.resultMapper) {
        return execContext.resultMapper(result, rootValue);
    }
    return result;
}
function executeField(field, rootValue, execContext) {
    var variables = execContext.variableValues, contextValue = execContext.contextValue, resolver = execContext.resolver;
    var fieldName = field.name.value;
    var args = storeUtils_1.argumentsObjectFromField(field, variables);
    var info = {
        isLeaf: !field.selectionSet,
        resultKey: storeUtils_1.resultKeyNameFromField(field),
    };
    var result = resolver(fieldName, rootValue, args, contextValue, info);
    if (!field.selectionSet) {
        return result;
    }
    if (isNull(result) || isUndefined(result)) {
        return result;
    }
    if (isArray(result)) {
        return executeSubSelectedArray(field, result, execContext);
    }
    return executeSelectionSet(field.selectionSet, result, execContext);
}
function executeSubSelectedArray(field, result, execContext) {
    return result.map(function (item) {
        if (isNull(item)) {
            return null;
        }
        if (isArray(item)) {
            return executeSubSelectedArray(field, item, execContext);
        }
        return executeSelectionSet(field.selectionSet, item, execContext);
    });
}
function handleFragmentErrors(fragmentErrors) {
    var typenames = Object.keys(fragmentErrors);
    if (typenames.length === 0) {
        return;
    }
    var errorTypes = typenames.filter(function (typename) {
        return (fragmentErrors[typename] !== null);
    });
    if (errorTypes.length === Object.keys(fragmentErrors).length) {
        throw fragmentErrors[errorTypes[0]];
    }
}
exports.handleFragmentErrors = handleFragmentErrors;
//# sourceMappingURL=index.js.map